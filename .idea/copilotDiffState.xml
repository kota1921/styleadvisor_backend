<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/prod_deploy.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/prod_deploy.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;# === Production deploy script ===&#10;# Шаги:&#10;# 1. Checkout ветки main.&#10;# 2. Проверка nginx синтаксиса и перезагрузка.&#10;# 3. Очистка venv, установка зависимостей.&#10;# 4. Проверка импорта server.py.&#10;# 5. Запуск тестов.&#10;# 6. Остановка старого Gunicorn (если запущен).&#10;# 7. Запуск продового сервера Gunicorn.&#10;# 8. Health-check.&#10;# Переменные: DRY_RUN=1, VERBOSE=1, SKIP_SERVER=1, SKIP_TESTS=1&#10;&#10;if [ -z &quot;$BASH_VERSION&quot; ]; then echo &quot;[ERROR] Используйте bash&quot;; exit 1; fi&#10;set -euo pipefail&#10;&#10;log_error(){ echo -e &quot;\033[0;31m[ERROR]\033[0m $1&quot;; }&#10;log_ok(){ echo -e &quot;\033[0;32m[OK]\033[0m $1&quot;; }&#10;log_info(){ echo -e &quot;\033[0;34m[INFO]\033[0m $1&quot;; }&#10;log_warn(){ echo -e &quot;\033[0;33m[WARN]\033[0m $1&quot;; }&#10;&#10;TOTAL_STEPS=8&#10;CURRENT_STEP=0&#10;&#10;print_progress(){&#10;  local step=$1&#10;  local message=&quot;$2&quot;&#10;  CURRENT_STEP=$step&#10;  local percent=$((step * 100 / TOTAL_STEPS))&#10;  local bar_len=40&#10;  local filled=$((bar_len * step / TOTAL_STEPS))&#10;  local empty=$((bar_len - filled))&#10;  printf &quot;\r\033[2K&quot;&#10;  printf &quot;\033[1;36m[%3d%%]\033[0m [&quot; &quot;$percent&quot;&#10;  printf &quot;%${filled}s&quot; | tr ' ' '█'&#10;  printf &quot;%${empty}s&quot; | tr ' ' '░'&#10;  printf &quot;] \033[1;37m%s\033[0m&quot; &quot;$message&quot;&#10;  if [ &quot;$step&quot; -eq &quot;$TOTAL_STEPS&quot; ]; then echo &quot;&quot;; fi&#10;}&#10;&#10;step_done(){&#10;  local message=&quot;${1:-}&quot;&#10;  if [ -n &quot;$message&quot; ]; then&#10;    printf &quot;\r\033[2K&quot;&#10;    log_ok &quot;$message&quot;&#10;  fi&#10;}&#10;&#10;step_fail(){&#10;  local message=&quot;$1&quot;&#10;  printf &quot;\r\033[2K&quot;&#10;  log_error &quot;$message&quot;&#10;}&#10;&#10;OS=&quot;$(uname -s)&quot;&#10;USE_BREW=0&#10;if [[ &quot;$OS&quot; == &quot;Darwin&quot; ]] &amp;&amp; command -v brew &gt;/dev/null 2&gt;&amp;1 &amp;&amp; brew list nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  USE_BREW=1&#10;fi&#10;&#10;if ! command -v nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_error &quot;nginx не установлен&quot;; exit 1&#10;fi&#10;&#10;# --- 1. Checkout main ---&#10;BRANCH=${BRANCH:-&quot;main&quot;}&#10;if [ -d .git ]; then&#10;  print_progress 1 &quot;Обновление git (${BRANCH})...&quot;&#10;  if git fetch origin &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \&#10;     git checkout &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \&#10;     git pull --ff-only origin &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;git checkout ${BRANCH} успешен&quot;&#10;  else&#10;    step_fail &quot;git checkout/pull не удался&quot;&#10;    git status&#10;    exit 1&#10;  fi&#10;else&#10;  print_progress 1 &quot;Git репозиторий не найден...&quot;&#10;  step_done &quot;Пропуск git (запуск из копии кода)&quot;&#10;fi&#10;&#10;print_progress 2 &quot;Проверка nginx...&quot;&#10;if [ $USE_BREW -eq 1 ]; then&#10;  if nginx -t &gt;/tmp/nginx_prod_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (brew)&quot;&#10;  else&#10;    step_fail &quot;nginx -t FAILED&quot;; cat /tmp/nginx_prod_output; exit 1&#10;  fi&#10;else&#10;  if sudo nginx -t &gt;/tmp/nginx_prod_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (system)&quot;&#10;  else&#10;    step_fail &quot;sudo nginx -t FAILED&quot;; cat /tmp/nginx_prod_output; exit 1&#10;  fi&#10;fi&#10;&#10;if [ &quot;${DRY_RUN:-0}&quot; = &quot;1&quot; ]; then&#10;  log_info &quot;DRY_RUN=1 — перезагрузка пропущена&quot;; exit 0&#10;fi&#10;&#10;reload_nginx(){&#10;  if [ $USE_BREW -eq 1 ]; then&#10;    if [ &quot;$EUID&quot; -eq 0 ]; then&#10;      if nginx -s reload; then return 0; fi&#10;      return 1&#10;    fi&#10;    if brew services restart nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    if nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  else&#10;    if command -v systemctl &gt;/dev/null 2&gt;&amp;1; then&#10;      if sudo systemctl reload nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    fi&#10;    if sudo nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  fi&#10;}&#10;&#10;print_progress 3 &quot;Перезагрузка nginx...&quot;&#10;if reload_nginx; then&#10;  if pgrep nginx &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;nginx перезагружен и запущен&quot;&#10;  else&#10;    step_fail &quot;nginx не запущен&quot;; exit 1&#10;  fi&#10;else&#10;  step_fail &quot;nginx reload FAILED&quot;; exit 1&#10;fi&#10;&#10;# --- Проверка и запуск продового сервера ---&#10;if [ &quot;${SKIP_SERVER:-0}&quot; != &quot;1&quot; ]; then&#10;  APP_DIR=&quot;$(pwd)&quot;&#10;  VENVDIR=&quot;${VENVDIR:-$APP_DIR/.venv}&quot;&#10;  PYTHON_BIN=&quot;${PYTHON_BIN:-python3}&quot;&#10;  REQFILE=&quot;${REQFILE:-$APP_DIR/requirements.txt}&quot;&#10;  GUNICORN_CMD=&quot;${GUNICORN_CMD:-gunicorn -w 4 server:app --bind 0.0.0.0:8000}&quot;&#10;  LOG_DIR=&quot;${LOG_DIR:-$APP_DIR/logs}&quot;&#10;  HEALTH_URL=&quot;${HEALTH_URL:-http://127.0.0.1:8000/auth/google}&quot;&#10;  HEALTH_TIMEOUT=&quot;${HEALTH_TIMEOUT:-30}&quot;&#10;&#10;  print_progress 4 &quot;Подготовка окружения...&quot;&#10;  if [ -d &quot;$VENVDIR&quot; ]; then rm -rf &quot;$VENVDIR&quot;; fi&#10;  $PYTHON_BIN -m venv &quot;$VENVDIR&quot;&#10;  source &quot;$VENVDIR/bin/activate&quot;&#10;  pip install --no-cache-dir --upgrade pip -q &gt;/dev/null 2&gt;&amp;1 || true&#10;  if [ -f &quot;$REQFILE&quot; ]; then&#10;    pip install --no-cache-dir -q -r &quot;$REQFILE&quot; &gt;/dev/null 2&gt;&amp;1&#10;  fi&#10;  step_done &quot;venv создан, зависимости установлены&quot;&#10;&#10;  print_progress 5 &quot;Проверка кода...&quot;&#10;  if ! python -c &quot;import server&quot; 2&gt;/dev/null; then&#10;    step_fail &quot;Импорт server.py не удался&quot;; exit 1&#10;  fi&#10;  step_done &quot;Импорт server.py успешен&quot;&#10;&#10;  if [ &quot;${SKIP_TESTS:-0}&quot; != &quot;1&quot; ]; then&#10;    print_progress 6 &quot;Запуск тестов...&quot;&#10;    if python -c &quot;import pytest&quot; 2&gt;/dev/null; then&#10;      export PYTHONPATH=&quot;$APP_DIR&quot;&#10;      if pytest -q &gt;/tmp/pytest_prod_output 2&gt;&amp;1; then&#10;        step_done &quot;Тесты прошли&quot;&#10;      else&#10;        step_fail &quot;Тесты не прошли&quot;; cat /tmp/pytest_prod_output; exit 1&#10;      fi&#10;    else&#10;      step_done &quot;pytest не установлен, пропуск&quot;&#10;    fi&#10;  else&#10;    print_progress 6 &quot;Тесты пропущены (SKIP_TESTS=1)&quot;&#10;    step_done &quot;&quot;&#10;  fi&#10;&#10;  print_progress 7 &quot;Запуск Gunicorn...&quot;&#10;  if [ -f /tmp/gunicorn_prod.pid ]; then&#10;    OLD_PID=$(cat /tmp/gunicorn_prod.pid)&#10;    if ps -p $OLD_PID &gt;/dev/null 2&gt;&amp;1; then&#10;      kill $OLD_PID 2&gt;/dev/null || true&#10;      sleep 2&#10;      if ps -p $OLD_PID &gt;/dev/null 2&gt;&amp;1; then kill -9 $OLD_PID 2&gt;/dev/null || true; fi&#10;    fi&#10;    rm -f /tmp/gunicorn_prod.pid&#10;  fi&#10;&#10;  # Проверка и освобождение порта 8000&#10;  if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;    PORT_PID=$(lsof -nP -iTCP:8000 -sTCP:LISTEN | tail -1 | awk '{print $2}')&#10;    if [ -n &quot;$PORT_PID&quot; ]; then&#10;      kill $PORT_PID 2&gt;/dev/null || true&#10;      sleep 2&#10;      if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;        kill -9 $PORT_PID 2&gt;/dev/null || true&#10;        sleep 1&#10;      fi&#10;    fi&#10;  fi&#10;&#10;  if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;    step_fail &quot;Порт 8000 всё ещё занят после принудительной остановки&quot;; exit 1&#10;  fi&#10;&#10;  mkdir -p &quot;$LOG_DIR&quot;&#10;  $GUNICORN_CMD --access-logfile &quot;$LOG_DIR/access.log&quot; --error-logfile &quot;$LOG_DIR/error.log&quot; --daemon&#10;  sleep 2&#10;  GUNICORN_PID=$(pgrep -f &quot;gunicorn.*server:app&quot; | head -1)&#10;  if [ -z &quot;$GUNICORN_PID&quot; ]; then&#10;    step_fail &quot;Gunicorn не запустился&quot;&#10;    if [ -f &quot;$LOG_DIR/error.log&quot; ]; then tail -n 20 &quot;$LOG_DIR/error.log&quot;; fi&#10;    exit 1&#10;  fi&#10;  echo &quot;$GUNICORN_PID&quot; &gt; /tmp/gunicorn_prod.pid&#10;  step_done &quot;Gunicorn запущен (PID=$GUNICORN_PID)&quot;&#10;&#10;  print_progress 8 &quot;Health-check...&quot;&#10;  start_ts=$(date +%s)&#10;  health_ok=0&#10;  while true; do&#10;    if ! ps -p $GUNICORN_PID &gt;/dev/null 2&gt;&amp;1; then&#10;      step_fail &quot;Gunicorn завершился досрочно&quot;; exit 1&#10;    fi&#10;    code=$(curl -s -o /dev/null -w '%{http_code}' &quot;$HEALTH_URL&quot; 2&gt;/dev/null || echo &quot;000&quot;)&#10;    if [[ &quot;$code&quot; =~ ^[0-9]{3}$ ]]; then&#10;      if [ &quot;$code&quot; -ge 200 ] &amp;&amp; [ &quot;$code&quot; -lt 500 ]; then&#10;        health_ok=1; break&#10;      fi&#10;    fi&#10;    now=$(date +%s)&#10;    elapsed=$((now - start_ts))&#10;    if [ $elapsed -ge $HEALTH_TIMEOUT ]; then&#10;      step_fail &quot;Health-check провалился (код=$code)&quot;; exit 1&#10;    fi&#10;    print_progress 8 &quot;Health-check... ${elapsed}/${HEALTH_TIMEOUT}s&quot;&#10;    sleep 1&#10;  done&#10;  if [ $health_ok -eq 1 ]; then&#10;    step_done &quot;Health-check успешен (код=$code)&quot;&#10;  fi&#10;fi&#10;&#10;if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then&#10;  LOG_CANDIDATES=(&#10;    /var/log/nginx/error.log&#10;    /usr/local/var/log/nginx/error.log&#10;    /opt/homebrew/var/log/nginx/error.log&#10;  )&#10;  for lf in &quot;${LOG_CANDIDATES[@]}&quot;; do&#10;    if [ -f &quot;$lf&quot; ]; then&#10;      if [ $USE_BREW -eq 1 ]; then&#10;        echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;      else&#10;        if [[ &quot;$lf&quot; == /var/log/nginx/error.log ]]; then&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; sudo tail -n 10 &quot;$lf&quot; || true&#10;        else&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;        fi&#10;      fi&#10;      break&#10;    fi&#10;  done&#10;fi&#10;&#10;echo &quot;&quot;&#10;log_ok &quot;PROD DEPLOY SUCCESS&quot;&#10;&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;# === Production deploy script ===&#10;# Шаги:&#10;# 1. Checkout ветки main.&#10;# 2. Проверка nginx синтаксиса и перезагрузка.&#10;# 3. Очистка venv, установка зависимостей.&#10;# 4. Проверка импорта server.py.&#10;# 5. Запуск тестов.&#10;# 6. Остановка старого Gunicorn (если запущен).&#10;# 7. Запуск продового сервера Gunicorn.&#10;# 8. Health-check.&#10;# Переменные: DRY_RUN=1, VERBOSE=1, SKIP_SERVER=1, SKIP_TESTS=1&#10;&#10;if [ -z &quot;$BASH_VERSION&quot; ]; then echo &quot;[ERROR] Используйте bash&quot;; exit 1; fi&#10;set -euo pipefail&#10;&#10;log_error(){ echo -e &quot;\033[0;31m[ERROR]\033[0m $1&quot;; }&#10;log_ok(){ echo -e &quot;\033[0;32m[OK]\033[0m $1&quot;; }&#10;log_info(){ echo -e &quot;\033[0;34m[INFO]\033[0m $1&quot;; }&#10;log_warn(){ echo -e &quot;\033[0;33m[WARN]\033[0m $1&quot;; }&#10;&#10;TOTAL_STEPS=8&#10;CURRENT_STEP=0&#10;&#10;print_progress(){&#10;  local step=$1&#10;  local message=&quot;$2&quot;&#10;  CURRENT_STEP=$step&#10;  local percent=$((step * 100 / TOTAL_STEPS))&#10;  local bar_len=40&#10;  local filled=$((bar_len * step / TOTAL_STEPS))&#10;  local empty=$((bar_len - filled))&#10;  printf &quot;\r\033[2K&quot;&#10;  printf &quot;\033[1;36m[%3d%%]\033[0m [&quot; &quot;$percent&quot;&#10;  printf &quot;%${filled}s&quot; | tr ' ' '█'&#10;  printf &quot;%${empty}s&quot; | tr ' ' '░'&#10;  printf &quot;] \033[1;37m%s\033[0m&quot; &quot;$message&quot;&#10;  if [ &quot;$step&quot; -eq &quot;$TOTAL_STEPS&quot; ]; then echo &quot;&quot;; fi&#10;}&#10;&#10;step_done(){&#10;  local message=&quot;${1:-}&quot;&#10;  if [ -n &quot;$message&quot; ]; then&#10;    printf &quot;\r\033[2K&quot;&#10;    log_ok &quot;$message&quot;&#10;  fi&#10;}&#10;&#10;step_fail(){&#10;  local message=&quot;$1&quot;&#10;  printf &quot;\r\033[2K&quot;&#10;  log_error &quot;$message&quot;&#10;}&#10;&#10;OS=&quot;$(uname -s)&quot;&#10;USE_BREW=0&#10;if [[ &quot;$OS&quot; == &quot;Darwin&quot; ]] &amp;&amp; command -v brew &gt;/dev/null 2&gt;&amp;1 &amp;&amp; brew list nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  USE_BREW=1&#10;fi&#10;&#10;if ! command -v nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_error &quot;nginx не установлен&quot;; exit 1&#10;fi&#10;&#10;# --- 1. Checkout main ---&#10;BRANCH=${BRANCH:-&quot;main&quot;}&#10;if [ -d .git ]; then&#10;  print_progress 1 &quot;Обновление git (${BRANCH})...&quot;&#10;  if git fetch origin &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \&#10;     git checkout &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \&#10;     git pull --ff-only origin &quot;$BRANCH&quot; &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;git checkout ${BRANCH} успешен&quot;&#10;  else&#10;    step_fail &quot;git checkout/pull не удался&quot;&#10;    git status&#10;    exit 1&#10;  fi&#10;else&#10;  print_progress 1 &quot;Git репозиторий не найден...&quot;&#10;  step_done &quot;Пропуск git (запуск из копии кода)&quot;&#10;fi&#10;&#10;print_progress 2 &quot;Проверка nginx...&quot;&#10;if [ $USE_BREW -eq 1 ]; then&#10;  if nginx -t &gt;/tmp/nginx_prod_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (brew)&quot;&#10;  else&#10;    step_fail &quot;nginx -t FAILED&quot;; cat /tmp/nginx_prod_output; exit 1&#10;  fi&#10;else&#10;  if sudo nginx -t &gt;/tmp/nginx_prod_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (system)&quot;&#10;  else&#10;    step_fail &quot;sudo nginx -t FAILED&quot;; cat /tmp/nginx_prod_output; exit 1&#10;  fi&#10;fi&#10;&#10;if [ &quot;${DRY_RUN:-0}&quot; = &quot;1&quot; ]; then&#10;  log_info &quot;DRY_RUN=1 — перезагрузка пропущена&quot;; exit 0&#10;fi&#10;&#10;reload_nginx(){&#10;  if [ $USE_BREW -eq 1 ]; then&#10;    if [ &quot;$EUID&quot; -eq 0 ]; then&#10;      if nginx -s reload; then return 0; fi&#10;      return 1&#10;    fi&#10;    if brew services restart nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    if nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  else&#10;    if command -v systemctl &gt;/dev/null 2&gt;&amp;1; then&#10;      if sudo systemctl reload nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    fi&#10;    if sudo nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  fi&#10;}&#10;&#10;print_progress 3 &quot;Перезагрузка nginx...&quot;&#10;if reload_nginx; then&#10;  if pgrep nginx &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;nginx перезагружен и запущен&quot;&#10;  else&#10;    step_fail &quot;nginx не запущен&quot;; exit 1&#10;  fi&#10;else&#10;  step_fail &quot;nginx reload FAILED&quot;; exit 1&#10;fi&#10;&#10;# --- Проверка и запуск продового сервера ---&#10;if [ &quot;${SKIP_SERVER:-0}&quot; != &quot;1&quot; ]; then&#10;  APP_DIR=&quot;$(pwd)&quot;&#10;  VENVDIR=&quot;${VENVDIR:-$APP_DIR/.venv}&quot;&#10;  PYTHON_BIN=&quot;${PYTHON_BIN:-python3}&quot;&#10;  REQFILE=&quot;${REQFILE:-$APP_DIR/requirements.txt}&quot;&#10;  GUNICORN_CMD=&quot;${GUNICORN_CMD:-gunicorn -w 4 server:app --bind 0.0.0.0:8000}&quot;&#10;  LOG_DIR=&quot;${LOG_DIR:-$APP_DIR/logs}&quot;&#10;  HEALTH_URL=&quot;${HEALTH_URL:-http://127.0.0.1:8000/auth/google}&quot;&#10;  HEALTH_TIMEOUT=&quot;${HEALTH_TIMEOUT:-30}&quot;&#10;&#10;  print_progress 4 &quot;Подготовка окружения...&quot;&#10;  if [ -d &quot;$VENVDIR&quot; ]; then rm -rf &quot;$VENVDIR&quot;; fi&#10;  $PYTHON_BIN -m venv &quot;$VENVDIR&quot;&#10;  source &quot;$VENVDIR/bin/activate&quot;&#10;  pip install --no-cache-dir --upgrade pip -q &gt;/dev/null 2&gt;&amp;1 || true&#10;  if [ -f &quot;$REQFILE&quot; ]; then&#10;    pip install --no-cache-dir -q -r &quot;$REQFILE&quot; &gt;/dev/null 2&gt;&amp;1&#10;  fi&#10;  step_done &quot;venv создан, зависимости установлены&quot;&#10;&#10;  print_progress 5 &quot;Проверка кода...&quot;&#10;  if ! python -c &quot;import server&quot; 2&gt;/dev/null; then&#10;    step_fail &quot;Импорт server.py не удался&quot;; exit 1&#10;  fi&#10;  step_done &quot;Импорт server.py успешен&quot;&#10;&#10;  if [ &quot;${SKIP_TESTS:-0}&quot; != &quot;1&quot; ]; then&#10;    print_progress 6 &quot;Запуск тестов...&quot;&#10;    if python -c &quot;import pytest&quot; 2&gt;/dev/null; then&#10;      export PYTHONPATH=&quot;$APP_DIR&quot;&#10;      if pytest -q &gt;/tmp/pytest_prod_output 2&gt;&amp;1; then&#10;        step_done &quot;Тесты прошли&quot;&#10;      else&#10;        step_fail &quot;Тесты не прошли&quot;; cat /tmp/pytest_prod_output; exit 1&#10;      fi&#10;    else&#10;      step_done &quot;pytest не установлен, пропуск&quot;&#10;    fi&#10;  else&#10;    print_progress 6 &quot;Тесты пропущены (SKIP_TESTS=1)&quot;&#10;    step_done &quot;&quot;&#10;  fi&#10;&#10;  print_progress 7 &quot;Запуск Gunicorn...&quot;&#10;  if [ -f /tmp/gunicorn_prod.pid ]; then&#10;    OLD_PID=$(cat /tmp/gunicorn_prod.pid)&#10;    if ps -p $OLD_PID &gt;/dev/null 2&gt;&amp;1; then&#10;      kill $OLD_PID 2&gt;/dev/null || true&#10;      sleep 2&#10;      if ps -p $OLD_PID &gt;/dev/null 2&gt;&amp;1; then kill -9 $OLD_PID 2&gt;/dev/null || true; fi&#10;    fi&#10;    rm -f /tmp/gunicorn_prod.pid&#10;  fi&#10;&#10;  # Агрессивное освобождение порта 8000&#10;  MAX_ATTEMPTS=3&#10;  for attempt in $(seq 1 $MAX_ATTEMPTS); do&#10;    if ! lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;      break&#10;    fi&#10;    &#10;    # Найти все PID на порту 8000&#10;    PORT_PIDS=$(lsof -nP -iTCP:8000 -sTCP:LISTEN | tail -n +2 | awk '{print $2}' | sort -u)&#10;    if [ -z &quot;$PORT_PIDS&quot; ]; then&#10;      break&#10;    fi&#10;    &#10;    for pid in $PORT_PIDS; do&#10;      if [ &quot;$attempt&quot; -lt &quot;$MAX_ATTEMPTS&quot; ]; then&#10;        kill $pid 2&gt;/dev/null || true&#10;      else&#10;        kill -9 $pid 2&gt;/dev/null || true&#10;      fi&#10;    done&#10;    &#10;    sleep 2&#10;  done&#10;&#10;  if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;    step_fail &quot;Порт 8000 занят после $MAX_ATTEMPTS попыток&quot;&#10;    lsof -nP -iTCP:8000 -sTCP:LISTEN&#10;    exit 1&#10;  fi&#10;&#10;  mkdir -p &quot;$LOG_DIR&quot;&#10;  $GUNICORN_CMD --access-logfile &quot;$LOG_DIR/access.log&quot; --error-logfile &quot;$LOG_DIR/error.log&quot; --daemon&#10;  sleep 2&#10;  GUNICORN_PID=$(pgrep -f &quot;gunicorn.*server:app&quot; | head -1)&#10;  if [ -z &quot;$GUNICORN_PID&quot; ]; then&#10;    step_fail &quot;Gunicorn не запустился&quot;&#10;    if [ -f &quot;$LOG_DIR/error.log&quot; ]; then tail -n 20 &quot;$LOG_DIR/error.log&quot;; fi&#10;    exit 1&#10;  fi&#10;  echo &quot;$GUNICORN_PID&quot; &gt; /tmp/gunicorn_prod.pid&#10;  step_done &quot;Gunicorn запущен (PID=$GUNICORN_PID)&quot;&#10;&#10;  print_progress 8 &quot;Health-check...&quot;&#10;  start_ts=$(date +%s)&#10;  health_ok=0&#10;  while true; do&#10;    if ! ps -p $GUNICORN_PID &gt;/dev/null 2&gt;&amp;1; then&#10;      step_fail &quot;Gunicorn завершился досрочно&quot;; exit 1&#10;    fi&#10;    code=$(curl -s -o /dev/null -w '%{http_code}' &quot;$HEALTH_URL&quot; 2&gt;/dev/null || echo &quot;000&quot;)&#10;    if [[ &quot;$code&quot; =~ ^[0-9]{3}$ ]]; then&#10;      if [ &quot;$code&quot; -ge 200 ] &amp;&amp; [ &quot;$code&quot; -lt 500 ]; then&#10;        health_ok=1; break&#10;      fi&#10;    fi&#10;    now=$(date +%s)&#10;    elapsed=$((now - start_ts))&#10;    if [ $elapsed -ge $HEALTH_TIMEOUT ]; then&#10;      step_fail &quot;Health-check провалился (код=$code)&quot;; exit 1&#10;    fi&#10;    print_progress 8 &quot;Health-check... ${elapsed}/${HEALTH_TIMEOUT}s&quot;&#10;    sleep 1&#10;  done&#10;  if [ $health_ok -eq 1 ]; then&#10;    step_done &quot;Health-check успешен (код=$code)&quot;&#10;  fi&#10;fi&#10;&#10;if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then&#10;  LOG_CANDIDATES=(&#10;    /var/log/nginx/error.log&#10;    /usr/local/var/log/nginx/error.log&#10;    /opt/homebrew/var/log/nginx/error.log&#10;  )&#10;  for lf in &quot;${LOG_CANDIDATES[@]}&quot;; do&#10;    if [ -f &quot;$lf&quot; ]; then&#10;      if [ $USE_BREW -eq 1 ]; then&#10;        echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;      else&#10;        if [[ &quot;$lf&quot; == /var/log/nginx/error.log ]]; then&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; sudo tail -n 10 &quot;$lf&quot; || true&#10;        else&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;        fi&#10;      fi&#10;      break&#10;    fi&#10;  done&#10;fi&#10;&#10;echo &quot;&quot;&#10;log_ok &quot;PROD DEPLOY SUCCESS&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_deploy.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_deploy.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;# === Local nginx config test script ===&#10;# Linux (systemd) -&gt; sudo systemctl reload nginx&#10;# macOS (brew nginx) -&gt; brew services restart nginx (без sudo), иначе nginx -s reload&#10;# Переменные: DRY_RUN=1, VERBOSE=1, SKIP_SERVER=1 (пропуск запуска Flask)&#10;&#10;if [ -z &quot;$BASH_VERSION&quot; ]; then echo &quot;[ERROR] Используйте bash&quot;; exit 1; fi&#10;set -euo pipefail&#10;&#10;log_error(){ echo -e &quot;\033[0;31m[ERROR]\033[0m $1&quot;; }&#10;log_ok(){ echo -e &quot;\033[0;32m[OK]\033[0m $1&quot;; }&#10;log_info(){ echo -e &quot;\033[0;34m[INFO]\033[0m $1&quot;; }&#10;log_warn(){ echo -e &quot;\033[0;33m[WARN]\033[0m $1&quot;; }&#10;&#10;OS=&quot;$(uname -s)&quot;&#10;USE_BREW=0&#10;if [[ &quot;$OS&quot; == &quot;Darwin&quot; ]] &amp;&amp; command -v brew &gt;/dev/null 2&gt;&amp;1 &amp;&amp; brew list nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  USE_BREW=1&#10;fi&#10;&#10;if ! command -v nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_error &quot;nginx не установлен&quot;; exit 1&#10;fi&#10;&#10;log_info &quot;Проверка синтаксиса nginx&quot;&#10;if [ $USE_BREW -eq 1 ]; then&#10;  if nginx -t 2&gt;&amp;1 | tee /tmp/nginx_test_output; then&#10;    log_ok &quot;Синтаксис OK (brew)&quot;&#10;  else&#10;    log_error &quot;nginx -t FAILED&quot;; exit 1&#10;  fi&#10;else&#10;  if sudo nginx -t 2&gt;&amp;1 | tee /tmp/nginx_test_output; then&#10;    log_ok &quot;Синтаксис OK (system)&quot;&#10;  else&#10;    log_error &quot;sudo nginx -t FAILED&quot;; exit 1&#10;  fi&#10;fi&#10;&#10;if [ &quot;${DRY_RUN:-0}&quot; = &quot;1&quot; ]; then&#10;  log_info &quot;DRY_RUN=1 — перезагрузка пропущена&quot;; exit 0&#10;fi&#10;&#10;reload_nginx(){&#10;  if [ $USE_BREW -eq 1 ]; then&#10;    if [ &quot;$EUID&quot; -eq 0 ]; then&#10;      log_warn &quot;macOS brew nginx: запущено под sudo — избегайте. Использую 'nginx -s reload'&quot;&#10;      if nginx -s reload; then return 0; fi&#10;      return 1&#10;    fi&#10;    if brew services restart nginx; then return 0; fi&#10;    log_warn &quot;brew services restart не удалось, пробую 'nginx -s reload'&quot;&#10;    if nginx -s reload; then return 0; fi&#10;    return 1&#10;  else&#10;    if command -v systemctl &gt;/dev/null 2&gt;&amp;1; then&#10;      if sudo systemctl reload nginx; then return 0; fi&#10;      log_warn &quot;systemctl reload не удалось, пробую 'sudo nginx -s reload'&quot;&#10;    fi&#10;    if sudo nginx -s reload; then return 0; fi&#10;    return 1&#10;  fi&#10;}&#10;&#10;log_info &quot;Перезагрузка nginx&quot;&#10;if reload_nginx; then&#10;  log_ok &quot;nginx reload OK&quot;&#10;else&#10;  log_error &quot;nginx reload FAILED&quot;; exit 1&#10;fi&#10;&#10;# Проверка что nginx запущен&#10;if pgrep nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_ok &quot;nginx запущен&quot;&#10;else&#10;  log_error &quot;nginx не запущен&quot;; exit 1&#10;fi&#10;&#10;# --- Проверка и запуск Flask сервера ---&#10;if [ &quot;${SKIP_SERVER:-0}&quot; != &quot;1&quot; ]; then&#10;  APP_DIR=&quot;$(pwd)&quot;&#10;  VENVDIR=&quot;${VENVDIR:-$APP_DIR/.venv}&quot;&#10;  PYTHON_BIN=&quot;${PYTHON_BIN:-python3}&quot;&#10;  REQFILE=&quot;${REQFILE:-$APP_DIR/requirements.txt}&quot;&#10;&#10;  log_info &quot;Проверка Flask сервера&quot;&#10;&#10;  # Очистка старого venv&#10;  if [ -d &quot;$VENVDIR&quot; ]; then&#10;    log_info &quot;Удаление старого venv&quot;&#10;    rm -rf &quot;$VENVDIR&quot;&#10;  fi&#10;&#10;  log_info &quot;Создание venv&quot;&#10;  $PYTHON_BIN -m venv &quot;$VENVDIR&quot;&#10;&#10;  source &quot;$VENVDIR/bin/activate&quot;&#10;&#10;  log_info &quot;Обновление pip&quot;&#10;  pip install --no-cache-dir --upgrade pip -q || log_warn &quot;Не удалось обновить pip&quot;&#10;&#10;  if [ -f &quot;$REQFILE&quot; ]; then&#10;    log_info &quot;Установка зависимостей&quot;&#10;    pip install --no-cache-dir -q -r &quot;$REQFILE&quot; || log_warn &quot;Не удалось установить зависимости&quot;&#10;  else&#10;    log_warn &quot;requirements.txt не найден, пропуск установки зависимостей&quot;&#10;  fi&#10;&#10;  if ! python -c &quot;import server&quot; 2&gt;/dev/null; then&#10;    log_error &quot;Импорт server.py не удался&quot;; exit 1&#10;  fi&#10;  log_ok &quot;Импорт server.py успешен&quot;&#10;&#10;  # Прогон тестов&#10;  if python -c &quot;import pytest&quot; 2&gt;/dev/null; then&#10;    log_info &quot;Запуск тестов&quot;&#10;    export PYTHONPATH=&quot;$APP_DIR&quot;&#10;    if pytest -q; then&#10;      log_ok &quot;Тесты прошли&quot;&#10;    else&#10;      log_error &quot;Тесты не прошли&quot;; exit 1&#10;    fi&#10;  else&#10;    log_warn &quot;pytest не установлен, пропуск тестов&quot;&#10;  fi&#10;&#10;  if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;    log_warn &quot;Порт 8000 занят, пропуск запуска&quot;&#10;  else&#10;    log_info &quot;Запуск Flask dev server&quot;&#10;    python -m flask --app server run --host 127.0.0.1 --port 8000 &gt;/tmp/flask_test.log 2&gt;&amp;1 &amp;&#10;    FLASK_PID=$!&#10;    sleep 3&#10;    if ps -p $FLASK_PID &gt;/dev/null 2&gt;&amp;1; then&#10;      log_ok &quot;Flask запущен (PID=$FLASK_PID)&quot;&#10;      if curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8000/auth/google | grep -qE '^[0-9]{3}$'; then&#10;        log_ok &quot;Flask отвечает на запросы&quot;&#10;      else&#10;        log_warn &quot;Flask не отвечает на запросы&quot;&#10;      fi&#10;      log_info &quot;Flask оставлен запущенным (остановка: kill $FLASK_PID)&quot;&#10;      echo &quot;$FLASK_PID&quot; &gt; /tmp/flask_test.pid&#10;    else&#10;      log_error &quot;Flask не запустился&quot;&#10;      if [ -f /tmp/flask_test.log ]; then&#10;        log_error &quot;Логи Flask:&quot;&#10;        cat /tmp/flask_test.log&#10;      fi&#10;      exit 1&#10;    fi&#10;  fi&#10;fi&#10;&#10;if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then&#10;  LOG_CANDIDATES=(&#10;    /var/log/nginx/error.log&#10;    /usr/local/var/log/nginx/error.log&#10;    /opt/homebrew/var/log/nginx/error.log&#10;  )&#10;  for lf in &quot;${LOG_CANDIDATES[@]}&quot;; do&#10;    if [ -f &quot;$lf&quot; ]; then&#10;      if [ $USE_BREW -eq 1 ]; then&#10;        log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;      else&#10;        if [[ &quot;$lf&quot; == /var/log/nginx/error.log ]]; then&#10;          log_info &quot;Последние 10 строк $lf&quot;; sudo tail -n 10 &quot;$lf&quot; || true&#10;        else&#10;          log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;        fi&#10;      fi&#10;      break&#10;    fi&#10;  done&#10;fi&#10;&#10;log_ok &quot;TEST DEPLOY SUCCESS&quot;&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;# === Local nginx config test script ===&#10;# Linux (systemd) -&gt; sudo systemctl reload nginx&#10;# macOS (brew nginx) -&gt; brew services restart nginx (без sudo), иначе nginx -s reload&#10;# Переменные: DRY_RUN=1, VERBOSE=1, SKIP_SERVER=1 (пропуск запуска Flask)&#10;&#10;if [ -z &quot;$BASH_VERSION&quot; ]; then echo &quot;[ERROR] Используйте bash&quot;; exit 1; fi&#10;set -euo pipefail&#10;&#10;log_error(){ echo -e &quot;\033[0;31m[ERROR]\033[0m $1&quot;; }&#10;log_ok(){ echo -e &quot;\033[0;32m[OK]\033[0m $1&quot;; }&#10;log_info(){ echo -e &quot;\033[0;34m[INFO]\033[0m $1&quot;; }&#10;log_warn(){ echo -e &quot;\033[0;33m[WARN]\033[0m $1&quot;; }&#10;&#10;TOTAL_STEPS=6&#10;CURRENT_STEP=0&#10;&#10;print_progress(){&#10;  local step=$1&#10;  local message=&quot;$2&quot;&#10;  CURRENT_STEP=$step&#10;  local percent=$((step * 100 / TOTAL_STEPS))&#10;  local bar_len=40&#10;  local filled=$((bar_len * step / TOTAL_STEPS))&#10;  local empty=$((bar_len - filled))&#10;  printf &quot;\r\033[2K&quot;&#10;  printf &quot;\033[1;36m[%3d%%]\033[0m [&quot; &quot;$percent&quot;&#10;  printf &quot;%${filled}s&quot; | tr ' ' '█'&#10;  printf &quot;%${empty}s&quot; | tr ' ' '░'&#10;  printf &quot;] \033[1;37m%s\033[0m&quot; &quot;$message&quot;&#10;  if [ &quot;$step&quot; -eq &quot;$TOTAL_STEPS&quot; ]; then echo &quot;&quot;; fi&#10;}&#10;&#10;step_done(){&#10;  local message=&quot;${1:-}&quot;&#10;  if [ -n &quot;$message&quot; ]; then&#10;    printf &quot;\r\033[2K&quot;&#10;    log_ok &quot;$message&quot;&#10;  fi&#10;}&#10;&#10;step_fail(){&#10;  local message=&quot;$1&quot;&#10;  printf &quot;\r\033[2K&quot;&#10;  log_error &quot;$message&quot;&#10;}&#10;&#10;OS=&quot;$(uname -s)&quot;&#10;USE_BREW=0&#10;if [[ &quot;$OS&quot; == &quot;Darwin&quot; ]] &amp;&amp; command -v brew &gt;/dev/null 2&gt;&amp;1 &amp;&amp; brew list nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  USE_BREW=1&#10;fi&#10;&#10;if ! command -v nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_error &quot;nginx не установлен&quot;; exit 1&#10;fi&#10;&#10;print_progress 1 &quot;Проверка nginx...&quot;&#10;if [ $USE_BREW -eq 1 ]; then&#10;  if nginx -t &gt;/tmp/nginx_test_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (brew)&quot;&#10;  else&#10;    step_fail &quot;nginx -t FAILED&quot;; cat /tmp/nginx_test_output; exit 1&#10;  fi&#10;else&#10;  if sudo nginx -t &gt;/tmp/nginx_test_output 2&gt;&amp;1; then&#10;    step_done &quot;nginx синтаксис OK (system)&quot;&#10;  else&#10;    step_fail &quot;sudo nginx -t FAILED&quot;; cat /tmp/nginx_test_output; exit 1&#10;  fi&#10;fi&#10;&#10;if [ &quot;${DRY_RUN:-0}&quot; = &quot;1&quot; ]; then&#10;  log_info &quot;DRY_RUN=1 — перезагрузка пропущена&quot;; exit 0&#10;fi&#10;&#10;reload_nginx(){&#10;  if [ $USE_BREW -eq 1 ]; then&#10;    if [ &quot;$EUID&quot; -eq 0 ]; then&#10;      if nginx -s reload; then return 0; fi&#10;      return 1&#10;    fi&#10;    if brew services restart nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    if nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  else&#10;    if command -v systemctl &gt;/dev/null 2&gt;&amp;1; then&#10;      if sudo systemctl reload nginx &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    fi&#10;    if sudo nginx -s reload &gt;/dev/null 2&gt;&amp;1; then return 0; fi&#10;    return 1&#10;  fi&#10;}&#10;&#10;print_progress 2 &quot;Перезагрузка nginx...&quot;&#10;if reload_nginx; then&#10;  if pgrep nginx &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;nginx перезагружен и запущен&quot;&#10;  else&#10;    step_fail &quot;nginx не запущен&quot;; exit 1&#10;  fi&#10;else&#10;  step_fail &quot;nginx reload FAILED&quot;; exit 1&#10;fi&#10;&#10;# Проверка что nginx запущен&#10;if pgrep nginx &gt;/dev/null 2&gt;&amp;1; then&#10;  log_ok &quot;nginx запущен&quot;&#10;else&#10;  log_error &quot;nginx не запущен&quot;; exit 1&#10;fi&#10;&#10;# --- Проверка и запуск Flask сервера ---&#10;if [ &quot;${SKIP_SERVER:-0}&quot; != &quot;1&quot; ]; then&#10;  APP_DIR=&quot;$(pwd)&quot;&#10;  VENVDIR=&quot;${VENVDIR:-$APP_DIR/.venv}&quot;&#10;  PYTHON_BIN=&quot;${PYTHON_BIN:-python3}&quot;&#10;  REQFILE=&quot;${REQFILE:-$APP_DIR/requirements.txt}&quot;&#10;&#10;  print_progress 3 &quot;Подготовка окружения...&quot;&#10;  # Очистка старого venv&#10;  if [ -d &quot;$VENVDIR&quot; ]; then&#10;    rm -rf &quot;$VENVDIR&quot;&#10;  fi&#10;&#10;  # Создание venv&#10;  $PYTHON_BIN -m venv &quot;$VENVDIR&quot;&#10;&#10;  source &quot;$VENVDIR/bin/activate&quot;&#10;&#10;  # Обновление pip&#10;  pip install --no-cache-dir --upgrade pip -q &gt;/dev/null 2&gt;&amp;1 || true&#10;&#10;  if [ -f &quot;$REQFILE&quot; ]; then&#10;    # Установка зависимостей&#10;    pip install --no-cache-dir -q -r &quot;$REQFILE&quot; &gt;/dev/null 2&gt;&amp;1&#10;  fi&#10;  step_done &quot;venv создан, зависимости установлены&quot;&#10;&#10;  print_progress 4 &quot;Проверка кода...&quot;&#10;  if ! python -c &quot;import server&quot; 2&gt;/dev/null; then&#10;    step_fail &quot;Импорт server.py не удался&quot;; exit 1&#10;  fi&#10;&#10;  if python -c &quot;import pytest&quot; 2&gt;/dev/null; then&#10;    export PYTHONPATH=&quot;$APP_DIR&quot;&#10;    if pytest -q &gt;/tmp/pytest_test_output 2&gt;&amp;1; then&#10;      step_done &quot;Импорт OK, тесты прошли&quot;&#10;    else&#10;      step_fail &quot;Тесты не прошли&quot;; cat /tmp/pytest_test_output; exit 1&#10;    fi&#10;  else&#10;    step_done &quot;Импорт OK, pytest не установлен&quot;&#10;  fi&#10;&#10;  # Проверка и освобождение порта 8000&#10;  if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;    # Агрессивное освобождение порта 8000&#10;    MAX_ATTEMPTS=3&#10;    for attempt in $(seq 1 $MAX_ATTEMPTS); do&#10;      if ! lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;        break&#10;      fi&#10;      &#10;      PORT_PIDS=$(lsof -nP -iTCP:8000 -sTCP:LISTEN | tail -n +2 | awk '{print $2}' | sort -u)&#10;      if [ -z &quot;$PORT_PIDS&quot; ]; then&#10;        break&#10;      fi&#10;      &#10;      for pid in $PORT_PIDS; do&#10;        if [ &quot;$attempt&quot; -lt &quot;$MAX_ATTEMPTS&quot; ]; then&#10;          kill $pid 2&gt;/dev/null || true&#10;        else&#10;          kill -9 $pid 2&gt;/dev/null || true&#10;        fi&#10;      done&#10;      &#10;      sleep 2&#10;    done&#10;&#10;    if lsof -nP -iTCP:8000 -sTCP:LISTEN &gt;/dev/null 2&gt;&amp;1; then&#10;      step_fail &quot;Порт 8000 занят после $MAX_ATTEMPTS попыток&quot;&#10;      lsof -nP -iTCP:8000 -sTCP:LISTEN&#10;      exit 1&#10;    fi&#10;    step_done &quot;Порт 8000 освобождён&quot;&#10;  fi&#10;&#10;  print_progress 5 &quot;Запуск Flask dev server...&quot;&#10;  python -m flask --app server run --host 127.0.0.1 --port 8000 &gt;/tmp/flask_test.log 2&gt;&amp;1 &amp;&#10;  FLASK_PID=$!&#10;  sleep 3&#10;  if ps -p $FLASK_PID &gt;/dev/null 2&gt;&amp;1; then&#10;    step_done &quot;Flask запущен (PID=$FLASK_PID)&quot;&#10;    print_progress 6 &quot;Проверка ответа Flask...&quot;&#10;    if curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8000/auth/google | grep -qE '^[0-9]{3}$'; then&#10;      step_done &quot;Flask отвечает, оставлен запущенным&quot;&#10;      echo &quot;$FLASK_PID&quot; &gt; /tmp/flask_test.pid&#10;    else&#10;      step_fail &quot;Flask не отвечает на запросы&quot;&#10;    fi&#10;  else&#10;    step_fail &quot;Flask не запустился&quot;&#10;    if [ -f /tmp/flask_test.log ]; then cat /tmp/flask_test.log; fi&#10;    exit 1&#10;  fi&#10;fi&#10;&#10;if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then&#10;  LOG_CANDIDATES=(&#10;    /var/log/nginx/error.log&#10;    /usr/local/var/log/nginx/error.log&#10;    /opt/homebrew/var/log/nginx/error.log&#10;  )&#10;  for lf in &quot;${LOG_CANDIDATES[@]}&quot;; do&#10;    if [ -f &quot;$lf&quot; ]; then&#10;      if [ $USE_BREW -eq 1 ]; then&#10;        echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;      else&#10;        if [[ &quot;$lf&quot; == /var/log/nginx/error.log ]]; then&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; sudo tail -n 10 &quot;$lf&quot; || true&#10;        else&#10;          echo &quot;&quot;; log_info &quot;Последние 10 строк $lf&quot;; tail -n 10 &quot;$lf&quot; || true&#10;        fi&#10;      fi&#10;      break&#10;    fi&#10;  done&#10;fi&#10;&#10;echo &quot;&quot;&#10;log_ok &quot;TEST DEPLOY SUCCESS&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>