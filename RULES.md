# Project Rules & Guidelines

(Содержимое перенесено из исходного README.md)

## Раздел: Краткий алгоритм работы по TDD (будем ему следовать)

Цикл (RED → GREEN → REFACTOR):
1. Формулируй ожидаемое поведение (user story / мини-сценарий) одной строкой: GIVEN / WHEN / THEN.
2. Пиши минимальный тест (pytest) фиксирующий новое поведение. Он должен падать (RED) по понятной причине (AssertionError / ожидаемое исключение ещё не реализовано).
3. Запусти тесты: убедись, что новый тест действительно красный и причина корректна.
4. Реализуй минимально достаточный код для прохождения теста (не оптимизируй раньше времени).
5. Запусти тесты снова: добейся зелёного (GREEN).
6. Рефакторинг: убери дублирование, улучшай читаемость, не меняя поведение. Тесты должны оставаться зелёными (REFACTOR).
7. Добавь дополнительные edge-case тесты (пустые входы, ошибки, границы). Повтори цикл.

Дополнение про мелкие шаги и прозрачность:
- Двигаемся МАЛЕНЬКИМИ инкрементами: один тест / одна причина падения / одно исправление.
- Каждый шаг озвучивается: что делаю сейчас, зачем, ожидаемый результат.
- Не объединяем несвязанные правки в один шаг (минимум шума, проще ревью / откат).
- Перед изменением кода: кратко формулирую цель; после — фиксирую факт (что изменилось) и состояние тестов.
- Если требуется исследование — отдельно помечаю фазу «исследование» без изменения состояния кода.
- Любая оптимизация только после подтверждения поведения (GREEN) и пометки, что это REFACTOR.

### Правила коммуникации ассистента (добавлено)
- Каждое сообщение краткое, без лишних деталей.
- Не выдумывать/расширять требования без явного указания.
- Не менять реализацию без предварительного аппрува пользователя.
- Отвечать всегда на русском.
- Если требуется уточнение — задать один чёткий вопрос.
- Если чего-то не знаю или нет данных в репозитории/окружении — прямо сказать «не знаю» и кратко указать причину (нет файла, нет логов, секрет недоступен и т.д.).

Правила тестов:
- Имена: `tests/test_<module>.py::test_<scenario>` — отражают поведение, не внутреннюю реализацию.
- Шаблон названия: `test_<function>__<given>__<expected>()` при сложных случаях.
- Структура внутри теста: AAA (Arrange / Act / Assert). Либо Given / When / Then комментариями.
- Один концептуальный assert — или несколько логически связанных. Для сложных структур prefer сравнение dict/модели целиком.
- Для исключений: `with pytest.raises(ExpectedError): ...`.
- Никаких реальных сетевых вызовов (OpenAI и т.п.) — использовать mocks / фикстуры.
- Тесты должны выполняться < 2s локально (стремиться к миллисекундам).
- Добавляй regression-тест при выявлении бага прежде чем фиксить.

Коммиты (если бы мы коммитили вручную):
- RED: можно коммитить (опционально, если нужна фиксация требований).
- GREEN: обязательный коммит «feat: implement <поведение> (green)».
- REFACTOR: коммит «refactor: <что улучшено> (no behavior change)».

Definition of Done для новой логики:
- Есть хотя бы 1 позитивный тест + минимум 1 edge / негативный.
- Покрыты основные ветви условий (if / error path).
- Нет дублированного кода, выявленного во время рефакторинга.

Буду далее cледовать этому алгоритму при добавлении/изменении функциональности.

### Coding Standards
- Python 3.13. Стиль: PEP8, длина строки 100.
- Форматирование: `ruff format` (при интеграции CI).
- Типы: добавлять при публичных функциях; не усложнять.

### Dependencies & Security
- Все зависимости в `requirements.txt` фиксировать с `==`.
- Новая зависимость: причина + альтернатива (в PR/коммите описанием).
- Периодическая проверка уязвимостей (pip-audit) — в планируемом CI.

### Error Handling & Logging
- Пользовательские ошибки: ValueError / CustomError с кратким сообщением.
- Не логировать секреты / токены.
- Логи структурированные (минимум: level, msg, context ID при наличии).

### Versioning & Commits
- SemVer (major.minor.patch) — при подготовке релизов (будет добавлено в CHANGELOG позже).
- Префиксы: feat, fix, refactor, docs, test, chore.

### Secrets & Config
- Только переменные окружения / Firebase Secrets.
- Запрет: хранить ключи в коде (кроме тестовых заглушек явно помеченных).
- Ротация секрета OpenAI не реже 90 дней.

### CI (Planned)
- Шаги: install → lint (ruff) → tests (pytest -q) → security (pip-audit) → build/deploy.
- PR без зелёного статуса — не мержится.

### Performance & Timeouts
- Сетевые вызовы: таймауты явно (будет внедрено при появлении сетевого слоя).
- Повторы (retries) с backoff — для идемпотентных операций.

### Naming & Docstrings
- Модули/файлы: snake_case.
- Функции/переменные: snake_case; классы: PascalCase.
- Docstring (Google style) у публичных функций, если не очевидно.
- Комментарии минимальны: не дублировать код, не «обмазывать» очевидное; отдаём приоритет выразительным именам и маленьким функциям.

### External Services Mock Policy
- Тесты не вызывают реальные API (OpenAI и т.п.).
- Использовать фикстуры / monkeypatch для изол��ции.

### Change Review Process
- Каждое изменение > 30 строк (кроме автоформата) требует обзор.
- Запрет смешивать фичу и рефакторинг без связи.

## Firebase Functions (Python) + OpenAI

Этот проект показывает, как безопасно использовать ключ OpenAI в Python Cloud Functions для Firebase.

## Хранение ключа в Firebase (секрет)
Никогда не коммитьте реальный ключ (`sk-...`) в репозиторий.

1. Установите ключ как секрет (один раз / при ротации):
```bash
firebase functions:secrets:set OPENAI_API_KEY
```
Вставьте значение ключа при запросе (оно не сохранится в истории shell).

2. Задеплойте функции (секрет подтянется автоматически):
```bash
firebase deploy --only functions
```

3. При выполнении функции среда исполнения предоставит переменную окружения `OPENAI_API_KEY`.

4. Ротация (замена ключа):
```bash
firebase functions:secrets:set OPENAI_API_KEY
firebase deploy --only functions
```

## Локальная разработка
Есть два варианта:

### Вариант A: Экспорт переменной
```bash
export OPENAI_API_KEY="sk-proj-..."
```

### Вариант B: Файл `.env`
Создайте файл `.env` (он уже исключён из git через `.gitignore`):
```
OPENAI_API_KEY=sk-proj-...
```
Модуль `python-dotenv` автоматически загрузит его при старте (см. `main.py`).

## Код инициализации
В `main.py` ключ читается так:
```python
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)
```
Если переменная не найдена — выбрасывается ош��бка (fail-fast), чтобы н�� пропустить неправильную конфигурацию.

## Вызов функции
После деплоя URL будет вида:
```
https://<REGION>-<PROJECT_ID>.cloudfunctions.net/on_request_example?text=Привет
```
Проверьте через curl:
```bash
curl "https://<REGION>-<PROJECT_ID>.cloudfunctions.net/on_request_example?text=Hello"
```

## Смена модели
Сейчас используется `gpt-4o-mini`. Замените на доступную в вашем аккаунте модель:
```python
response = client.responses.create(
    model="gpt-4o-mini",
    input=original,
)
```

## Обработка ответа
Ответ SDK сериализуется в JSON с ��чётом наличия `to_dict()` / `model_dump()`.

## Безопасность
- Не вставляйте ключ напрямую в код или README.
- Ограничьте права членов проекта Firebase.
- Регулярно ротируйте ключ, если он когда-либо раскрывался.
- Можно добавить квоты и мониторинг в OpenAI Dashboard.

## Возможные улучшения (Next steps)
- Добавить ограничение длины входного текста.
- Логирование (structured) без утечки PII и ключей.
- Юнит-тесты (mock OpenAI клиента).
- Rate limiting / кеш.
- Обработка таймаутов и повторов.

## Быстрый чеклист
- [x] Ключ хранится как секрет / переменная окружения
- [x] Локальная поддержка `.env`
- [x] Исключён `.env` из git
- [x] Добавлен `python-dotenv`

---
Если нужно — могу добавить пример тестов или утилиту для безопасной ротации ключа.
